# mypy: disallow_untyped_defs=True
from collections import defaultdict
from typing import DefaultDict, List, Set
from flask import current_app
from config.general import (
    DEPLOYMENT_NAME,
    DEPLOYMENT_FULL_NAME,
    DEPLOYMENT_BASE_URL,
    DEPLOYMENT_SHORT_NAME,
)
from config.ui import DEFAULT_LOCALE, FULL_PLATFORM_NAME
from log import LOG
from web.python_client.alerts_service.model import AlertDefinition, AlertNotification
from web.server.data.data_access import Transaction
from web.server.errors import NotificationError
from web.server.potion.access import get_id_from_uri
from web.server.util.email_client import EmailMessage, EmailClient
from web.server.util.emails import EmailRenderer

from models.alchemy.permission import RESOURCE_ROLE_NAMES, ResourceRole
from models.alchemy.security_group import GroupAcl, GroupUsers
from models.alchemy.user import User, UserAcl

ENABLED_DEPLOYMENTS = {}

ALERT_LINK_OVERRIDE_MAP = {}
DEFAULT_ALERT_URL_SUFFIX = 'alerts'

ALERT_RESOURCE_ROLES_NAMES = [
    RESOURCE_ROLE_NAMES['ALERT_ADMIN'],
    RESOURCE_ROLE_NAMES['ALERT_CREATOR'],
    RESOURCE_ROLE_NAMES['ALERT_EDITOR'],
    RESOURCE_ROLE_NAMES['ALERT_VIEWER'],
]


def get_alert_link(host: str) -> str:
    url_suffix = ALERT_LINK_OVERRIDE_MAP.get(DEPLOYMENT_NAME, DEFAULT_ALERT_URL_SUFFIX)
    return f'{host}/{url_suffix}'


def generate_notification_objects(
    alert_definitions: List[AlertDefinition], notification_list: List[AlertNotification]
) -> List[dict]:
    '''Generate a list of dictionaries that are of the following format:
    {
        'title': str,
        'dimensions': str,
    }
    '''
    # dict where key is alert definition's uri to a list of alert notifications
    # generated by that alert_definition
    def_uri_to_notif_list_map = defaultdict(list)
    for notification in notification_list:
        def_uri_to_notif_list_map[notification.alert_definition.ref].append(
            notification
        )

    def_uri_to_alert_map = {alert_def.uri: alert_def for alert_def in alert_definitions}

    entry_list = []
    for def_uri, same_def_notifs in def_uri_to_notif_list_map.items():
        alert_def = def_uri_to_alert_map[def_uri]

        dimension_str_list = [
            notif.dimension_info.get(alert_def.dimension_name).dimension_val
            for notif in same_def_notifs
            if alert_def.dimension_name in notif.dimension_info
        ]
        dimensions_str = ', '.join(dimension_str_list)

        entry_list.append(
            {
                'title': alert_def.title,
                'dimensions': dimensions_str,
            }
        )

    return entry_list


def send_email(email_msg: EmailMessage) -> None:
    smtp_config = current_app.config.get('SMTP_CONFIG')
    email_client = EmailClient(**smtp_config)
    try:
        email_client.send(email_msg)
    except NotificationError as e:
        LOG.error('Failed to send alert notification emails. Reason: %s', e.message)
        return

    LOG.info('Successfully sent alert notification emails')


def get_alert_resource_role_ids(transaction: Transaction) -> Set[int]:
    '''Returns a set of ids of Alert related ResourceRoles.'''
    alert_resource_role_id_set = set()
    for resource_role_name in ALERT_RESOURCE_ROLES_NAMES:
        resource_role = transaction.find_one_by_fields(
            ResourceRole, True, {'name': resource_role_name}
        )
        if resource_role:
            alert_resource_role_id_set.add(resource_role.id)
    return alert_resource_role_id_set


def build_users_to_alerts_mapping(
    transaction: Transaction,
) -> DefaultDict[int, Set[int]]:
    '''Returns a mapping of user id to a set of alert definition ids that
    represents the alert definitions that a user has at least view access to.
    '''
    alert_roles = get_alert_resource_role_ids(transaction)

    group_id_to_user_ids_map = defaultdict(set)
    for group_user in transaction.find_all_by_fields(GroupUsers, {}):
        group_id_to_user_ids_map[group_user.group_id].add(group_user.user_id)

    user_to_alert_mapping = defaultdict(set)
    for role_id in alert_roles:
        for user_acl in transaction.find_all_by_fields(
            UserAcl, {'resource_role_id': role_id}
        ):
            user_to_alert_mapping[user_acl.user_id].add(user_acl.resource_id)

        for group_acl in transaction.find_all_by_fields(
            GroupAcl, {'resource_role_id': role_id}
        ):
            for user_id in group_id_to_user_ids_map[group_acl.group_id]:
                user_to_alert_mapping[user_id].add(group_acl.resource_id)

    return user_to_alert_mapping


def get_definition_to_notifications_map(
    notification_lst: List[AlertNotification],
) -> DefaultDict[int, AlertNotification]:
    '''Given a list of alert notifications, returns a mapping of alert
    definition id to a list of associated notifications.
    '''
    definition_to_notification_map = defaultdict(list)
    for notification_obj in notification_lst:
        definition_to_notification_map[
            get_id_from_uri(notification_obj.alert_definition.ref)
        ].append(notification_obj)
    return definition_to_notification_map


def get_permitted_notifications(
    permitted_definitions: Set[int],
    notification_map: DefaultDict[int, AlertNotification],
    definition_set: Set[int],
) -> List[AlertNotification]:
    '''Returns a list of notifications that a user can view from
    `notification_map` based on `permitted_definitions`.

    NOTE: We pass in both the map and set since we call this function on
    the same map multiple times
    '''
    user_allowed_definitions = permitted_definitions.intersection(definition_set)
    permitted_notification_lst = []
    for definition_id in user_allowed_definitions:
        permitted_notification_lst += notification_map[definition_id]
    return permitted_notification_lst


def maybe_send_alert_notifications(
    alert_definitions: List[AlertDefinition],
    new_notifications: List[AlertNotification],
    revised_notifications: List[AlertNotification],
    unchanged_notifications: List[AlertNotification],
    todays_prior_generated_notifications: List[AlertNotification],
    host: str,
    db_session,
    suppress_emails: bool = False,
) -> None:
    '''Send out email for new alerts and updated alerts, existing alerts from
    today are also included in a digest. Alert definition permissions are
    respected on a per-user basis.
    '''
    if DEPLOYMENT_NAME not in ENABLED_DEPLOYMENTS:
        return

    # If there are no new notifications then return
    if not new_notifications:
        LOG.info('No new notifications')
        return

    # Compute notifications for individual users
    with Transaction(get_session=lambda: db_session) as transaction:
        user_to_alert_mapping = build_users_to_alerts_mapping(transaction)

        email_renderer = EmailRenderer(
            DEFAULT_LOCALE,
            DEPLOYMENT_NAME,
            DEPLOYMENT_FULL_NAME,
            DEPLOYMENT_SHORT_NAME,
            DEPLOYMENT_BASE_URL,
            FULL_PLATFORM_NAME,
        )

        # The two sets that we care about are 1) notifications from new data
        # (new updated notifs, and 2) current notifications but stale (no
        # changes)
        new_notifications = new_notifications + revised_notifications
        # NOTE: Only populate if pipeline was already run today and has data
        is_pipeline_run_today = len(todays_prior_generated_notifications) > 0
        existing_notifications = (
            unchanged_notifications if is_pipeline_run_today else []
        )

        # We need alert_definition ID to list of notifications
        new_notifications_map = get_definition_to_notifications_map(new_notifications)
        new_definitions_set = set(new_notifications_map.keys())

        existing_notifications_map = get_definition_to_notifications_map(
            existing_notifications
        )
        existing_definitions_set = set(existing_notifications_map.keys())

        alert_link = get_alert_link(host)

        for user_id, alert_id_set in user_to_alert_mapping.items():
            new_user_notifications = get_permitted_notifications(
                alert_id_set, new_notifications_map, new_definitions_set
            )

            if not new_user_notifications:
                # If there are no new notifications for this user, there's no
                # need to send them a notification
                continue

            existing_user_notifications = get_permitted_notifications(
                alert_id_set, existing_notifications_map, existing_definitions_set
            )

            user_entity = transaction.find_by_id(User, user_id)
            if not user_entity:
                LOG.warning('Could not find user with id %s', user_id)
                continue

            email_recipients = [user_entity.username]
            LOG.info('Sending alert notification email to %s', email_recipients)

            email_msg = email_renderer.create_alert_notification_message(
                generate_notification_objects(
                    alert_definitions, new_user_notifications
                ),
                generate_notification_objects(
                    alert_definitions, existing_user_notifications
                ),
                email_recipients,
                alert_link,
            )
            if not suppress_emails:
                send_email(email_msg)
