from datetime import datetime
from http.client import NO_CONTENT, OK, UNAUTHORIZED
import re

from flask import g, url_for, current_app, request as flask_request
from flask_potion import fields
from flask_potion.schema import FieldSet
from flask_potion.contrib.alchemy import fields as alchemy_fields
from flask_potion.routes import Route, ItemRoute, Relation
from flask_potion.signals import after_create
from flask_potion.instances import Instances
from flask_principal import ItemNeed
import related

from data.query.models import GroupingDimension
from models.alchemy.dashboard import Dashboard
from models.alchemy.user import User, UserAcl, UserRoles
from models.alchemy.permission import (
    Role,
    ResourceRole,
    RESOURCE_ROLE_NAMES,
    SitewideResourceAcl,
)
from models.alchemy.schedule import SchedulerEntry
from models.alchemy.security_group import Group
from web.server.api.model_schemas import (
    QUERY_LINK_PATTERN,
    USERNAME_SCHEMA,
)
from web.server.api.api_models import PrincipalResource
from web.server.api.query.calculation_schema import CALCULATION_SCHEMA
from web.server.api.query.grouping_item_schema import GROUPING_DIMENSION_SCHEMA
from web.server.api.query.query_filter_schema import QUERY_FILTER_SCHEMA
from web.server.configuration.bots import BOT_USERS
from web.server.data.data_access import Transaction
from web.server.errors import NotificationError
from web.server.potion.filters import UserFilter
from web.server.query.request import QueryRequest
from web.server.routes.views.authorization import (
    AuthorizedOperation,
    authorization_required,
)
from web.server.routes.views.dashboard import (
    attach_my_roles_to_dashboard_query,
    attach_metadata_to_dashboard_query,
    add_item_holder_to_dashboard,
    api_bulk_transfer_dashboard_ownership,
    api_transfer_dashboard_ownership,
    DashboardManager,
    format_and_upgrade_specification,
    format_and_upgrade_specification_list,
    get_or_create_metadata,
    lookup_author,
    share_dashboard_via_email,
    format_and_downgrade_dashboard_list,
    format_and_downgrade_specification,
)
from web.server.routes.views.users import get_current_user
from web.server.security.permissions import SuperUserPermission, principals
from web.server.util.util import EMAIL_PATTERN, get_dashboard_title


# TODO - Allow users to change their Dashboard Slugs via the Settings
# Modal. Once this is done, we will restrict the ability to use whitespaces
# in dashboard slugs.
DASHBOARD_SLUG_PATTERN = r'(^[a-zA-Z0-9-_ ]*)$'

# The schema for the `selections` object that is POSTed to the `visualization` API. This
# essentially represents the selections generated by the Query Tool. We are not specifying
# A detailed schema for this object as it is not really necessary at this stage since the
# selections object is in flux and if the structure ever changes without this schema definition
# being altered, any APIs that reference this schema will reject the client request since it
# will not match the defined schema.
SELECTIONS_SCHEMA = fields.Custom(
    fields.Any(),
    description='The selections object containing the query to be added to a dashboard.',
)

# The schema for the `query_result_spec` object that is POSTed to the
# `visualization` API. This represents the frontend configuration for a query
# result (e.g. custom fields, filters, settings, etc.) We are not specifying a
# detailed schema for this object yet, but we should.
QUERY_RESULT_SPEC_SCHEMA = fields.Custom(
    fields.Any(),
    description='The query result spec object describing a query result and its configuration to be added to a dashboard.',
)


ADD_ITEM_HOLDER_TO_DASHBOARD_SCHEMA = fields.Object(
    properties={
        'id': fields.String(),
        'item': fields.Any(),
        'position': fields.Object(
            properties={
                'columnCount': fields.Integer(minimum=1),
                'rowCount': fields.Integer(minimum=1),
                # NOTE: only x of 0 is allowed here because `add_item_holder_to_dashboard`
                # does such an assumption for simplicity because we don't use other values
                # as of now
                'x': fields.Integer(minimum=0, maximum=0),
            }
        ),
    },
)

# The schema for the dashboard's specification. Because the specification is stored in the database
# as a text value, we must serialize and deserialize as part of retrieval / update.
# TODO - We can actually define the entire Dashboard Schema here.
# Determine if it's necessary.
# NOTE - This is actually a hack. The `io=w` signals to Potion that this is a write-only
# field when it is infact a readable field as well. The reason that we mark it as a write-only
# field is to prevent it from being shown in the `GET` call to the API root. We only want this
# field to be shown in the resource-specific `GET` call. The correct solution is to build this
# behaviour into Flask-Potion (configurable fields depending on query view / resource view).
SPECIFICATION_SCHEMA = fields.Custom(
    fields.Any(),
    description='The JSON specification that is used to render the dashboard.',
    converter=format_and_upgrade_specification,
    formatter=format_and_upgrade_specification,
    io='w',
)

SPECIFICATION_ARRAY_SCHEMA = fields.Custom(
    fields.Array(
        fields.Object({'slug': fields.String(), 'specification': fields.Any()})
    ),
    description='An array of dashboard JSON specifications.',
    default=[],
    converter=format_and_upgrade_specification_list,
    formatter=format_and_upgrade_specification_list,
    io='w',
)

NULLABLE_SLUG_SCHEMA = fields.String(
    description='The short name that is used to compute the URL for the UI representation '
    'of this dashboard. If it is not specified during creation, it will be '
    'inferred from the title embedded in the dashboard specification.',
    pattern=DASHBOARD_SLUG_PATTERN,
    nullable=True,
)

TITLE_SCHEMA = fields.Custom(
    fields.String(), attribute='specification', formatter=get_dashboard_title, io='r'
)

DESCRIPTION_SCHEMA = fields.String(
    description='A short description of the dashboard.', nullable=True
)

AUTHOR_USERNAME_SCHEMA = fields.Custom(
    fields.Email(pattern=EMAIL_PATTERN, nullable=True),
    description='The author\'s username. If not visible to the user, this will be null.',
    attribute='author_username',
    io='r',
)

AUTHOR_URI_SCHEMA = fields.ItemUri(
    'web.server.api.user_api_models.UserResource', attribute='author_id'
)

RESOURCE_URI_SCHEMA = fields.ItemUri(
    'web.server.api.permission_api_models.BackendResource', attribute='resource_id'
)

CREATED_SCHEMA = fields.DateTimeString(
    description='When the dashboard was created.', attribute='created', io='r'
)

LAST_MODIFIED_SCHEMA = fields.DateTimeString(
    description='The last time the dashboard was modified.',
    attribute='last_modified_real',
    io='r',
)

IS_OFFICIAL_SCHEMA = fields.Boolean(
    attribute='is_official',
    description='Indicates whether or not an administrator has flagged the '
    'dashboard as "official" or not.',
    io='r',
)

REGISTERED_USERS_CAN_DOWNLOAD_DATA_SCHEMA = fields.Boolean(
    attribute='registered_users_can_download_data',
    description='Indicates whether or not registered users can download analysis data',
    io='r',
)

UNREGISTERED_USERS_CAN_DOWNLOAD_DATA_SCHEMA = fields.Boolean(
    attribute='unregistered_users_can_download_data',
    description='Indicates whether or not unregistered users can download analysis data',
    io='r',
)

IS_FAVORITE_SCHEMA = fields.Boolean(
    description='Indicates whether or not the dashboard has been favorited by the current user.',
    attribute='is_favorite',
    io='r',
)

LAST_ACCESSED_BY_USER_SCHEMA = fields.DateTimeString(
    description='The last time the dashboard was accessed (if ever) by the current user.',
    nullable=True,
    attribute='last_accessed_by_user',
    io='r',
)

LAST_MODIFIED_BY_USER_SCHEMA = fields.DateTimeString(
    description='The last time the dashboard was edited (if ever) by the current user.',
    nullable=True,
    attribute='last_modified_by_user',
    io='r',
)

TOTAL_VIEWS_BY_USER_SCHEMA = fields.Integer(
    description='The total number of times the current user has viewed the dashboard.',
    minimum=0,
    attribute='total_views_by_user',
    io='r',
)

TOTAL_VIEWS_SCHEMA = fields.Integer(
    description='The total number of times the dashboard has been viewed.',
    minimum=0,
    attribute='total_views_real',
    io='r',
)

DASHBOARD_BASE_FIELDS = {
    '$uri': fields.ItemUri(
        'web.server.api.dashboard_api_models.DashboardResource', attribute='resource_id'
    ),
    'title': TITLE_SCHEMA,
    'slug': NULLABLE_SLUG_SCHEMA,
    'description': DESCRIPTION_SCHEMA,
    'author': AUTHOR_URI_SCHEMA,
    'authorUsername': AUTHOR_USERNAME_SCHEMA,
    'resource': RESOURCE_URI_SCHEMA,
    'created': CREATED_SCHEMA,
    'isOfficial': IS_OFFICIAL_SCHEMA,
    'registeredUsersCanDownloadData': REGISTERED_USERS_CAN_DOWNLOAD_DATA_SCHEMA,
    'unregisteredUsersCanDownloadData': UNREGISTERED_USERS_CAN_DOWNLOAD_DATA_SCHEMA,
}

DASHBOARD_METADATA_FIELDS = {
    'isFavorite': IS_FAVORITE_SCHEMA,
    'lastAccessedByCurrentUser': LAST_ACCESSED_BY_USER_SCHEMA,
    'lastModified': LAST_MODIFIED_SCHEMA,
    'lastModifiedByCurrentUser': LAST_MODIFIED_BY_USER_SCHEMA,
    'totalViews': TOTAL_VIEWS_SCHEMA,
    'totalViewsByUser': TOTAL_VIEWS_BY_USER_SCHEMA,
}

DASHBOARD_SIMPLE_FIELDS = {
    **DASHBOARD_BASE_FIELDS,
    **DASHBOARD_METADATA_FIELDS,
    # NOTE: The dashboard title is exposed inside `attach_metadata_to_dashboard_query`
    # by using Postgres JSONB column functionality to extract the title value from
    # the spec entirely inside Postgres. This makes it so we don't need to load the
    # specification locally to access the value.
    'title': fields.String(attribute='title', io='r'),
}

DASHBOARD_WITH_MY_ROLES = {
    **DASHBOARD_SIMPLE_FIELDS,
    'myRoles': fields.Array(fields.String, attribute='my_roles', io='r'),
}

# Not the prettiest solution to getting the URI to appear in the overriden GET/PATCH Schema but it
# works for now. One option would be to override the ModelResource Meta and add a new property
# (e.g. 'single_view_fields') which would only serialize certain fields if viewing a single resource
# item as opposed to a list.
# TODO - Figure out how to do this in a better way.
DASHBOARD_DETAILED_FIELDS = {
    'specification': SPECIFICATION_SCHEMA,
    **DASHBOARD_SIMPLE_FIELDS,
}

DETAILED_DASHBOARD_SCHEMA = alchemy_fields.InlineModel(
    DASHBOARD_DETAILED_FIELDS, model=Dashboard, description='The dashboard model.'
)

USER_URI_SCHEMA = fields.ItemUri('web.server.api.user_api_models.UserResource')


# Schemas for properties that are never sent by the user but must be stubbed
# out to make flask potion happy.
UNUSED_LAST_MODIFIED_SCHEMA = fields.DateTimeString(
    description='The last time the dashboard was modified.',
    attribute='last_modified',
    io='r',
)

UNUSED_TOTAL_VIEWS_SCHEMA = fields.Integer(
    description='The total number of times the dashboard has been viewed.',
    minimum=0,
    attribute='total_views',
    io='r',
)


def find_dashboard_by_slug(slug: str, transaction: Transaction) -> Dashboard:
    return transaction.find_all_by_fields(Dashboard, {'slug': slug}).first()


class DashboardResource(PrincipalResource):
    '''The potion class for performing CRUD operations on the `Dashboard` class.'''

    resource = Relation('resource', io='r')
    author = Relation('user', io='r')

    class Meta:
        manager = principals(DashboardManager)
        model = Dashboard
        natural_key = 'slug'
        excluded_fields = ('id',)
        id_attribute = 'resource_id'

        permissions = {'read': 'view_resource'}

        filters = {
            'slug': True,
            'title': True,
            'created': True,
            'author': {'eq': UserFilter, None: UserFilter},
            'isOfficial': True,
        }

    class Schema:
        title = TITLE_SCHEMA
        slug = NULLABLE_SLUG_SCHEMA
        description = DESCRIPTION_SCHEMA
        specification = SPECIFICATION_SCHEMA
        authorUsername = AUTHOR_USERNAME_SCHEMA
        author = AUTHOR_URI_SCHEMA
        resource = RESOURCE_URI_SCHEMA
        created = CREATED_SCHEMA
        isOfficial = IS_OFFICIAL_SCHEMA
        registeredUsersCanDowloadData = REGISTERED_USERS_CAN_DOWNLOAD_DATA_SCHEMA
        unregisteredUsersCanDowloadData = UNREGISTERED_USERS_CAN_DOWNLOAD_DATA_SCHEMA

        # NOTE: These fields are now pulled **from metadata** not from
        # the Dashboard model directly. They are only represented here to make
        # flask potion happy EVEN THOUGH THEY WILL NEVER EVER BE SENT BY THE
        # CLIENT, FLASK POTION STILL COMPLAINS.
        lastModified = UNUSED_LAST_MODIFIED_SCHEMA
        totalViews = UNUSED_TOTAL_VIEWS_SCHEMA

    # NOTE: To ensure endpoints that return a single dashboard also
    # include the appropriate metadata, we must join in the dashboard metadata
    # to our single dashboard query.
    def _get_single_dashboard_with_metadata(self, resource_id, use_legacy_spec=False):
        # NOTE: The resource_id being filtered on here is **not**
        # Dashboard.id. This is because we use the `resource_id` column for
        # lookups and reference.
        # pylint: disable=protected-access
        query = self.manager._query().filter(self.manager.id_column == resource_id)
        return attach_metadata_to_dashboard_query(
            query, True, use_legacy_spec=use_legacy_spec
        ).one()

    # Override the default dashboard creation POST function so we can return
    # a dashboard with all the necessary metadata (except for the specification)
    @Route.POST(
        '',
        rel='create',
        title='Create a dashboard and return DASHBOARD_SIMPLE_FIELDS',
        schema=fields.Object({'slug': fields.String(), 'specification': fields.Any()}),
        response_schema=fields.Object(DASHBOARD_SIMPLE_FIELDS),
    )
    def create_dashboard(self, dashboard_info):
        with AuthorizedOperation('create_resource', 'dashboard'):
            return self.manager.create_dashboard(**dashboard_info)

    # Override the default "get all dashboards" route to augment the response
    # with dashboard specific metadata.
    @Route.GET(
        '',
        rel='instances',
        title='Get all dashboards',
        description='Gets all dashboards',
        schema=Instances(),
        response_schema=fields.Array(fields.Object(DASHBOARD_WITH_MY_ROLES)),
    )
    def get_instances(self, page, per_page, where, sort):
        base_query = self.manager.instances(where, sort)

        # NOTE: I'm not sure why this wouldn't exist, but I think it
        # only happens when there are no dashboards in the DB.
        if not base_query:
            return []

        return (
            attach_my_roles_to_dashboard_query(
                attach_metadata_to_dashboard_query(base_query)
            )
            .paginate(page, per_page)
            .items
        )

    @Route.GET(
        '/viewable',
        title='Retrieve all dashboards the user can view',
        schema=Instances(),
        response_schema=fields.Array(fields.Object(DASHBOARD_SIMPLE_FIELDS)),
    )
    def get_viewable_dashboards(self, page, per_page, where, sort):
        base_query = self.manager.instances(where, sort)
        # If query is empty, return empty list
        if not base_query:
            return []

        # Explicitly return all dashboards for admins
        if SuperUserPermission().can():
            return (
                attach_metadata_to_dashboard_query(base_query)
                .paginate(page=page, per_page=per_page)
                .items
            )

        # pylint: disable=C0103
        viewable_dashboard_resource_id_list = [
            item.value
            for item in g.identity.provides
            if (
                isinstance(item, ItemNeed)
                and item.type == 'dashboard'
                and item.method == 'view_resource'
            )
        ]
        return (
            attach_metadata_to_dashboard_query(
                base_query.filter(
                    Dashboard.resource_id.in_(viewable_dashboard_resource_id_list)
                )
            )
            .paginate(page=page, per_page=per_page)
            .items
        )

    @ItemRoute.POST(
        '/cannot_view',
        title='List recipients that cannot view dashboard',
        description='Get recipients can view dashboard and returning all users with no access',
        schema=fields.Object({'emails': fields.Array(USERNAME_SCHEMA, min_items=0)}),
        response_schema=fields.Array(USERNAME_SCHEMA),
    )
    def get_no_access_recipients(self, dashboard, data):
        emails = data.get('emails')
        if not emails:
            return []
        with Transaction() as transaction:
            session = transaction.run_raw()

            roles = [
                RESOURCE_ROLE_NAMES['DASHBOARD_VIEWER'],
                RESOURCE_ROLE_NAMES['DASHBOARD_EDITOR'],
                RESOURCE_ROLE_NAMES['DASHBOARD_ADMIN'],
            ]

            # when dashboard resource has sitewide access all registered users can see it
            if (
                session.query(SitewideResourceAcl)
                .filter(SitewideResourceAcl.resource_id == dashboard.resource_id)
                .first()
            ):
                return []

            # any superusers in provided emails should have access to
            # the dashboard already
            super_users = [
                email
                for col in (
                    session.query(User.username)
                    .filter(User.username.in_(emails))
                    .join(UserRoles)
                    .join(Role)
                    .filter(Role.name.in_(['admin']))
                    .all()
                )
                for email in col
            ]

            # find users with access to the resource
            have_access = [
                email
                for col in (
                    session.query(User.username)
                    .filter(User.username.in_(emails))
                    .join(UserAcl)
                    .filter(UserAcl.resource_id == dashboard.resource_id)
                    .join(ResourceRole)
                    .filter(ResourceRole.name.in_(roles))
                    .all()
                )
                for email in col
            ]
            have_access.extend(super_users)

            # return users with no access
            return list(set(emails) - set(have_access))

    @Route.GET(
        '/editable',
        title='Dashboards that this user can edit',
        response_schema=fields.Array(fields.Object(DASHBOARD_SIMPLE_FIELDS)),
    )
    def get_editable_instances(self):
        # Explicitly return all dashboards for admins
        base_query = self.manager.instances()
        if SuperUserPermission().can():
            return attach_metadata_to_dashboard_query(base_query)

        # Return all dashboards for users with Dashboard Admin role
        dashboard_admin_permissions = {
            'delete_resource',
            'update_users',
            'create_resource',
            'view_resource',
            'edit_resource',
        }
        user_dashboard_permissions = {
            item.method
            for item in g.identity.provides
            if (
                isinstance(item, ItemNeed)
                and item.type == 'dashboard'
                and item.value is None
            )
        }
        if user_dashboard_permissions == dashboard_admin_permissions:
            return attach_metadata_to_dashboard_query(base_query)

        # pylint: disable=C0103
        editable_dashboard_resource_id_list = [
            item.value
            for item in g.identity.provides
            if (
                isinstance(item, ItemNeed)
                and item.type == 'dashboard'
                and item.method == 'edit_resource'
            )
        ]
        # pylint: disable=no-member
        dashboard_query = Dashboard.query.filter(
            Dashboard.resource_id.in_(editable_dashboard_resource_id_list)
        )
        return attach_metadata_to_dashboard_query(dashboard_query).all()

    @Route.POST(
        '/upgrade_spec',
        title='Upgrade Dashboard Specification',
        description='Upgrades the provided dashboard specification to the '
        'latest schema version supported by the server.',
        schema=fields.Any(),
        rel='upgrade',
    )
    def upgrade_dashboard_spec(self, dashboard_specification):
        # The validation is being done in the conversion defined by SPECIFICATION_SCHEMA. If there
        # are any errors, they will be thrown as an exception to the client. No action needs to be
        # taken here.
        return format_and_upgrade_specification(dashboard_specification)

    @ItemRoute.POST(
        '/add_item',
        title='Add item to dashboard',
        schema=ADD_ITEM_HOLDER_TO_DASHBOARD_SCHEMA,
        response_schema=DETAILED_DASHBOARD_SCHEMA,
    )
    def add_item(self, dashboard, request):
        resource_id = dashboard.resource.id
        with AuthorizedOperation('edit_resource', 'dashboard', resource_id):
            add_item_holder_to_dashboard(dashboard, request)
            track_dashboard_access(
                dashboard.id, edited=True, increment_view_count=False
            )
            return self._get_single_dashboard_with_metadata(resource_id)

    @ItemRoute.POST(
        '/transfer',
        title='Transfer Ownership',
        description='Transfers the ownership of this dashboard from the current'
        'owner to the one specified. ',
        schema=USER_URI_SCHEMA,
    )
    def transfer_ownership(self, dashboard, new_author):
        with AuthorizedOperation(
            'update_users', 'dashboard', dashboard.resource_id
        ), AuthorizedOperation('view_resource', 'user', dashboard.author.id):
            new_author = lookup_author(author_id=new_author)
            api_transfer_dashboard_ownership(dashboard, new_author)
            return None, NO_CONTENT

    @ItemRoute.POST(
        '/transfer/username',
        title='Transfer Ownership',
        description='Transfers the ownership of this dashboard from the current'
        'owner to the one specified. ',
        schema=USERNAME_SCHEMA,
    )
    def transfer_ownership_by_username(self, dashboard, new_author):
        with AuthorizedOperation(
            'update_users', 'dashboard', dashboard.resource_id
        ), AuthorizedOperation('view_resource', 'user', dashboard.author.id):
            new_author = lookup_author(author_username=new_author)
            api_transfer_dashboard_ownership(dashboard, new_author)
            return None, NO_CONTENT

    @Route.POST(
        '/transfer',
        title='Transfer Ownership',
        description='Transfers the ownership of ALL dashboards from one user '
        'to another.',
        schema=fields.Object(
            {'sourceAuthor': USER_URI_SCHEMA, 'targetAuthor': USER_URI_SCHEMA}
        ),
    )
    @authorization_required('update_users', 'dashboard')
    def transfer_bulk_ownership(self, request):
        source_author = lookup_author(author_id=request['sourceAuthor'])
        target_author = lookup_author(author_id=request['targetAuthor'])
        api_bulk_transfer_dashboard_ownership(source_author, target_author)
        return None, NO_CONTENT

    @Route.POST(
        '/transfer/username',
        title='Transfer Ownership',
        description='Transfers the ownership of ALL dashboards from one user '
        'to another.',
        schema=fields.Object(
            {'sourceAuthor': USERNAME_SCHEMA, 'targetAuthor': USERNAME_SCHEMA}
        ),
    )
    @authorization_required('update_users', 'dashboard')
    def transfer_bulk_ownership_by_username(self, request):
        source_author = lookup_author(author_username=request['sourceAuthor'])
        target_author = lookup_author(author_username=request['targetAuthor'])
        api_bulk_transfer_dashboard_ownership(source_author, target_author)
        return None, NO_CONTENT

    @ItemRoute.POST(
        '/official',
        title='Update Dashboard \'official\' flag',
        description='Marks a Dashboard as official or not.',
        schema=fields.Boolean(
            description='The updated value of the "isOfficial" flag for the '
            'dashboard.'
        ),
    )
    @authorization_required('publish_resource', 'dashboard')
    def set_official(self, dashboard, is_official):
        self.manager.update(dashboard, {'is_official': is_official})
        return None, NO_CONTENT

    @ItemRoute.POST(
        '/favorite',
        title='Update Dashboard \'favorite\' flag',
        description='Marks a Dashboard as a user favorite or not.',
        schema=fields.Boolean(
            description='The updated value of the "isFavorite" flag for the '
            'dashboard.'
        ),
    )
    def set_favorite(self, dashboard, is_favorite):
        with AuthorizedOperation(
            'view_resource', 'dashboard', dashboard.id
        ), Transaction() as transaction:
            metadata = get_or_create_metadata(transaction, dashboard.id)
            metadata.is_favorite = is_favorite
            transaction.add_or_update(metadata)

        return None, NO_CONTENT

    @ItemRoute.POST(
        '/set_tile_data_permissions',
        title='Sets permissions for downloading of analysis data from dashboard',
        description='Manages downloading of analysis data from the dashboard',
        schema=fields.Object(
            properties={
                'registered_users_can_download_data': fields.Boolean(),
                'unregistered_users_can_download_data': fields.Boolean(),
            }
        ),
    )
    @authorization_required('publish_resource', 'dashboard')
    def set_tile_data_permissions(self, dashboard, new_permissions):
        self.manager.update(dashboard, new_permissions)
        return None, NO_CONTENT

    FIELD_SCHEMA = fields.Object(
        properties={'id': fields.String(), 'calculation': CALCULATION_SCHEMA}
    )

    QUERY_REQUEST = fields.Object(
        properties={
            'fields': fields.Array(FIELD_SCHEMA),
            'filter': QUERY_FILTER_SCHEMA,
            'groups': fields.Array(fields.Object(additional_properties=True)),
            'type': fields.String(),
        }
    )

    # NOTE: Why are we overriding the default potion route for GET <{}:id> and
    # PATCH <{}:id>?
    #
    # We want to only display the dashboard specification when an individual dashboard is
    # requested. To do this, we have to tailor the response schema to include the specification
    # field which would otherwise NOT be included in the default Schema specified in the `Schema`
    # subclass of `DashboardResource`.
    #
    # The rationale for only display the complete dashboard specification is that specifications
    # have a tendency to be very large and we don't want to send a lot of useless data over the
    # wire unless it is specifically asked for by the client. It is also very unlikely that a
    # client will ever be loading more than one dashboard specification at a given time.
    @Route.GET(
        lambda r: f'/<{r.meta.id_converter}:id>',
        rel='self',
        attribute='instance',
        response_schema=DETAILED_DASHBOARD_SCHEMA,
    )
    def read(self, id):
        with Transaction() as transaction:
            dashboard = super().read(id)
            dashboard.total_views += 1
            track_dashboard_access(dashboard.id)
            dashboard = transaction.add_or_update(dashboard, flush=True)

        # NOTE: Dirty hack to check if the user requested the legacy spec
        # version by passing it in the url params. The ability to view legacy specs is
        # a short lived feature and it's ok to make small hacks like this.
        use_legacy_spec = flask_request.args.get('legacy') == '1'
        return self._get_single_dashboard_with_metadata(id, use_legacy_spec)

    @Route.PATCH(
        lambda r: f'/<{r.meta.id_converter}:id>',
        rel='update',
        schema=fields.Inline('self', patchable=True),
        response_schema=DETAILED_DASHBOARD_SCHEMA,
    )
    def update(self, properties, id):
        dashboard = super().update(properties, id)
        track_dashboard_access(dashboard.id, edited=True)
        return self._get_single_dashboard_with_metadata(id)

    @ItemRoute.POST(
        '/share_via_email',
        title='Send emails',
        schema=fields.Object(
            properties={
                'recipients': fields.Array(fields.String()),
                'message': fields.String(),
                'subject': fields.String(),
                'sender': fields.String(),
                'shouldAttachPdf': fields.Boolean(attribute='should_attach_pdf'),
                'shouldEmbedImage': fields.Boolean(attribute='should_embed_image'),
                'dashboardUrl': fields.String(nullable=True, attribute='dashboard_url'),
                'isScheduledReport': fields.Boolean(
                    nullable=True, attribute='is_scheduled_report'
                ),
                'useRecipientQueryPolicy': fields.Boolean(
                    nullable=True, default=True, attribute='use_recipient_permissions'
                ),
                'useSingleEmailThread': fields.Boolean(
                    nullable=True, default=False, attribute='use_email_thread'
                ),
            }
        ),
        response_schema=fields.Any(),
    )
    def share_via_email(self, dashboard, request_obj):
        share_dashboard_via_email(
            dashboard,
            request_obj['recipients'],
            request_obj['message'],
            request_obj['subject'],
            request_obj['sender'],
            use_recipient_permissions=request_obj['use_recipient_permissions'],
            should_attach_pdf=request_obj['should_attach_pdf'],
            should_embed_image=request_obj['should_embed_image'],
            dashboard_url=request_obj['dashboard_url'],
            is_scheduled_report=request_obj['is_scheduled_report'],
            use_email_thread=request_obj['use_email_thread'],
        )
        return OK

    def get_user_group_emails(self, user_groups, transaction):
        if not user_groups:
            return []
        return [
            user.username
            for user in transaction.run_raw()
            .query(User.username)
            .filter(User.groups.any(Group.name.in_([grp.name for grp in user_groups])))
            .all()
        ]

    def query_security_groups(self, user_groups, transaction):
        if not user_groups:
            return []
        return (
            transaction.run_raw()
            .query(Group.id)
            .filter(Group.name.in_([grp.name for grp in user_groups]))
        )

    QUERY_LINK_RE = re.compile(QUERY_LINK_PATTERN)

    REPORT_QUERY_REQUEST = fields.Object(properties={'query': QUERY_REQUEST})

    def run_query(self, query):
        new_groups = []
        for grouping_dimension in query['groups']:
            deserialized_value = GROUPING_DIMENSION_SCHEMA.converter(grouping_dimension)
            new_groups.append(related.to_model(GroupingDimension, deserialized_value))
        query['groups'] = new_groups

        request = QueryRequest.polymorphic_to_model(query)
        query = request.to_druid_query(
            current_app.druid_context.current_datasource.name
        )
        variable_filters = query['dimensions']
        query_results = current_app.query_client.run_query(query).result

        return query_results, variable_filters

    # NOTE: This and the following two functions are used for internal testing.
    # Specifications are type any because we're not enforcing a specific version in
    # order to test properly
    @Route.GET(
        '/raw_dashboard_specs',
        title='Get raw (not upgraded) dashboard specs, used internally',
        response_schema=fields.Array(
            fields.Object({'slug': fields.String(), 'specification': fields.Any()})
        ),
    )
    def get_raw_dashboard_specs(self):
        # only allow admins access to this functionality
        if SuperUserPermission().can():
            with Transaction() as transaction:
                dashboards = transaction.find_all_by_fields(Dashboard, {})
                return [
                    {'slug': dashboard.slug, 'specification': dashboard.specification}
                    for dashboard in dashboards
                ]
        return None, UNAUTHORIZED

    @Route.GET(
        '/raw_dashboard_spec',
        title=(
            'Get raw (not upgraded) dashboard spec for a given slug. The '
            'specification is None if the slug could not be found.'
        ),
        schema=FieldSet({'slug': fields.String()}),
        response_schema=fields.Object({'specification': fields.Any()}),
    )
    def get_raw_dashboard_spec(self, slug):
        # only allow admins access to this functionality
        if SuperUserPermission().can():
            with Transaction() as transaction:
                dashboard = find_dashboard_by_slug(slug, transaction)
                if dashboard:
                    return {'specification': dashboard.specification}
                return {'specification': None}
        return None, UNAUTHORIZED

    @Route.GET(
        '/dashboard_specs',
        title='Get upgraded dashboard specs (without writing back to db).',
        # The SPECIFICATION_ARRAY_SCHEMA will handle upgrading the dashboard
        schema=FieldSet(
            # this value is used when we only care about testing all upgrades
            # (so we only care about a success/failure result). So in that case
            # we can skip returning the full array of all upgraded schemas,
            # because that can be a lot of data
            {'ignoreReturn': fields.Boolean(default=False, attribute='ignore_return')}
        ),
        response_schema=SPECIFICATION_ARRAY_SCHEMA,
    )
    def get_dashboard_specs(self, ignore_return):
        # only allow admins access to this functionality
        if SuperUserPermission().can():
            with Transaction() as transaction:
                dashboards = transaction.find_all_by_fields(Dashboard, {})
                dashboard_results = [
                    {'slug': dashboard.slug, 'specification': dashboard.specification}
                    for dashboard in dashboards
                ]

                if ignore_return:
                    # run the upgrade just to check if there are any errors
                    format_and_upgrade_specification_list(dashboard_results)
                    return []

                # the upgrade will get run by the SPECIFICATION_ARRAY_SCHEMA
                return dashboard_results
        return None, UNAUTHORIZED

    @Route.GET(
        '/dashboard_spec',
        title='Get upgraded dashboard spec for a given slug (without writing back to db).',
        schema=FieldSet({'slug': fields.String()}),
        # The SPECIFICATION_SCHEMA will handle upgrading the dashboard
        response_schema=fields.Object({'specification': SPECIFICATION_SCHEMA}),
    )
    def get_dashboard_spec(self, slug):
        # only allow admins access to this functionality
        if SuperUserPermission().can():
            with Transaction() as transaction:
                dashboard = find_dashboard_by_slug(slug, transaction)
                if dashboard:
                    return {'specification': dashboard.specification}
                return {'specification': None}
        return None, UNAUTHORIZED

    @Route.POST(
        '/upgrade',
        title='Upgrade dashboard',
        description='Upgrade a dashboard given a slug and write back to db',
        schema=FieldSet({'slug': fields.String()}),
    )
    def upgrade_dashboard(self, slug):
        # only allow admins access to this functionality
        if SuperUserPermission().can():
            with Transaction() as transaction:
                dashboard = find_dashboard_by_slug(slug, transaction)
                upgraded_spec = format_and_upgrade_specification(
                    dashboard.specification
                )
                dashboard.specification = upgraded_spec
                transaction.add_or_update(dashboard)
            return None, NO_CONTENT
        return None, UNAUTHORIZED

    @Route.POST(
        '/upgrade_all',
        title='Upgrade all dashboards',
        description='Upgrade all dashboards and write back to db',
    )
    def upgrade_all(self):
        # only allow admins access to this functionality
        if SuperUserPermission().can():
            with Transaction() as transaction:
                dashboards = transaction.find_all_by_fields(Dashboard, {})
                dashboard_slug_map = {d.slug: d for d in dashboards}
                upgraded_spec_tuples = format_and_upgrade_specification_list(
                    [(d.slug, d.specification) for d in dashboards]
                )

                # write back all the upgraded specs
                for spec_obj in upgraded_spec_tuples:
                    slug, spec = spec_obj['slug'], spec_obj['specification']
                    dashboard = dashboard_slug_map[slug]
                    dashboard.specification = spec
                    transaction.add_or_update(dashboard)
            return None, NO_CONTENT
        return None, UNAUTHORIZED

    @Route.POST(
        '/bulk_delete',
        title='Delete all dashboards identified by the given slugs',
        schema=FieldSet({'slugs': fields.Array(fields.String())}),
    )
    def bulk_delete(self, slugs):
        # only allow Admins access to this functionality. It is not intended
        # for public use. It is just a helper API for internal use.
        if SuperUserPermission().can():
            # pylint: disable=no-member
            dashboards = Dashboard.query.filter(Dashboard.slug.in_(slugs))
            with Transaction() as transaction:
                for dashboard in dashboards:
                    transaction.delete(dashboard)
            return None, NO_CONTENT
        return None, UNAUTHORIZED

    @Route.POST(
        '/delete_all',
        title='Delete all dashboards',
    )
    def delete_all(self):
        # only allow Admins access to this functionality. It is not intended
        # for public use. It is just a helper API for internal use.
        if SuperUserPermission().can():
            with Transaction() as transaction:
                dashboards = transaction.find_all_by_fields(Dashboard, {})
                for dashboard in dashboards:
                    transaction.delete(dashboard)
            return None, NO_CONTENT
        return None, UNAUTHORIZED

    @Route.GET(
        '/downgrade',
        title='Get downgraded dashboard spec',
        description='Get downgraded dashboard spec for a given slug (without writing back to db)',
        schema=FieldSet({'slug': fields.String()}),
        response_schema=fields.Any(),
    )
    def get_downgraded_dashboard(self, slug):
        # only allow admins access to this functionality
        if SuperUserPermission().can():
            with Transaction() as transaction:
                dashboard = find_dashboard_by_slug(slug, transaction)
                downgraded_spec = format_and_downgrade_specification(
                    dashboard.specification
                )
                return downgraded_spec
        return None, UNAUTHORIZED

    @Route.GET(
        '/downgrade_all',
        title='Get downgraded dashboard specs',
        description='Get downgraded dashboard specs given a version (without writing back to db).',
        schema=FieldSet({'version': fields.String()}),
        response_schema=fields.List(
            FieldSet({'slug': fields.String(), 'specification': fields.Any()})
        ),
    )
    def get_downgraded_all_dashboards(self, version):
        # only allow admins access to this functionality
        if SuperUserPermission().can():
            with Transaction() as transaction:
                session = transaction.run_raw()
                dashboards = session.query(Dashboard).filter(
                    Dashboard.specification['version'].astext == version
                )
                downgraded_specs = format_and_downgrade_dashboard_list(
                    dashboards,
                )
                return downgraded_specs
        return None, UNAUTHORIZED

    @Route.POST(
        '/downgrade',
        title='Downgrade dashboard spec',
        description='Downgrade a dashboard given a slug and write back to db',
        schema=FieldSet({'slug': fields.String()}),
    )
    def downgrade_dashboard(self, slug):
        # only allow admins access to this functionality
        if SuperUserPermission().can():
            with Transaction() as transaction:
                dashboard = find_dashboard_by_slug(slug, transaction)
                dashboard.specification = format_and_downgrade_specification(
                    dashboard.specification
                )
                transaction.add_or_update(dashboard)
            return None, NO_CONTENT
        return None, UNAUTHORIZED

    @Route.POST(
        '/downgrade_all',
        title='Downgrade all dashboards',
        description='Downgrade all dashboards given a version and write back to db',
        schema=FieldSet({'version': fields.String()}),
    )
    def downgrade_all_dashboards(self, version):
        # only allow admins access to this functionality
        if SuperUserPermission().can():
            with Transaction() as transaction:
                session = transaction.run_raw()
                dashboards = session.query(Dashboard).filter(
                    Dashboard.specification['version'].astext == version
                )
                slug_to_dashboard_map = {
                    dashboard.slug: dashboard for dashboard in dashboards
                }
                downgraded_specs = format_and_downgrade_dashboard_list(dashboards)

                # write back all the downgraded specs
                for spec_obj in downgraded_specs:
                    slug, spec = spec_obj['slug'], spec_obj['specification']
                    dashboard = slug_to_dashboard_map[slug]
                    dashboard.specification = spec
                    transaction.add_or_update(dashboard)
            return None, NO_CONTENT
        return None, UNAUTHORIZED


def track_dashboard_access(dashboard_id, edited=False, increment_view_count=True):
    if get_current_user().username in BOT_USERS:
        # Don't count views by bots.
        return

    with Transaction() as transaction:
        metadata = get_or_create_metadata(transaction, dashboard_id)
        now = datetime.utcnow()
        metadata.last_viewed = now

        if increment_view_count:
            metadata.views_by_user += 1
        if edited:
            metadata.last_edited = now
        transaction.add_or_update(metadata)


# pylint: disable=W0613
# Suppressing this warning because this is the method signature for signal handlers.
@after_create.connect_via(DashboardResource)
def send_email_after_create(sender, item):
    dashboard_link = url_for('dashboard.grid_dashboard', name=item.slug, _external=True)
    message = current_app.email_renderer.create_new_dashboard_message(
        item.author,
        current_app.zen_config.general.DEPLOYMENT_FULL_NAME,
        dashboard_link,
        item.resource.label,
        item.slug,
    )
    try:
        g.request_logger.info(
            'Sending new dashboard notification email to: \'%s\'', item.author_username
        )
        current_app.notification_service.send_email(message)
    except NotificationError:
        g.request_logger.error(
            'Failed to send new dashboard notification email to: \'%s\'',
            item.author_username,
        )


@after_create.connect_via(DashboardResource)
def generate_metadata_after_create(sender, item):
    with Transaction() as transaction:
        metadata = get_or_create_metadata(transaction, item.id)
        now = datetime.utcnow()
        metadata.last_viewed = now
        metadata.last_edited = now
        metadata.views_by_user = 0  # creation does not count as a view
        transaction.add_or_update(metadata)
        transaction.add_or_update(item)


RESOURCE_TYPES = [DashboardResource]
